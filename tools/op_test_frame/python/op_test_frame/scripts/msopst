#!/usr/bin/python3
# coding=utf-8
"""
Function:
This file mainly involves class for parsing input arguments.
Copyright Information:
Huawei Technologies Co., Ltd. All Rights Reserved Â© 2020
"""

import os
import sys
import argparse
from op_test_frame.st.interface import utils
from op_test_frame.st.interface.acl_op_runner import AclOpRunner
from op_test_frame.st.interface.ms_op_runner import MsOpRunner
from op_test_frame.st.interface import result_comparer
from op_test_frame.st.interface.acl_op_generator import AclOpGenerator
from op_test_frame.st.interface.ms_op_generator import MsOpGenerator
from op_test_frame.st.interface.case_design import CaseDesign
from op_test_frame.st.interface.case_generator import CaseGenerator
from op_test_frame.st.interface.data_generator import DataGenerator
from op_test_frame.st.interface.model_parser import change_shape
from op_test_frame.st.interface.model_parser import get_shape
from op_test_frame.st.interface import st_report
from op_test_frame.st.interface.advance_ini_parser import AdvanceIniParser
from atexit import register

abnormal_termination = False


def _check_device_id(device_id):
    if not device_id.isdigit():
        utils.print_error_log(
            'please enter an integer number for device id,'
            'now is %s.' % device_id)
        sys.exit(utils.OP_TEST_GEN_INVALID_DEVICE_ID_ERROR)
    return


def _generate_op_project(args, report, machine_type):
    # design test case list from json file
    design = CaseDesign(args.input_file, args.case_name, report)
    case_list = design.design()
    output_path = os.path.realpath(args.output_path)
    # create op project path and generate op test case code
    path_and_device_id = (output_path, args.device_id)
    if case_list[0].get('st_mode') == 'ms_python_train':
        ms_op_generator_instance = MsOpGenerator(
            case_list, path_and_device_id, machine_type, report)
        ms_op_generator_instance.generate()
    else:
        acl_op_generator_instance = AclOpGenerator(
            case_list, path_and_device_id, machine_type, report)
        acl_op_generator_instance.generate()

    # generate data
    data_generator = DataGenerator(case_list, output_path,
                                   machine_type, report)
    data_generator.generate()
    return case_list


def _runner_and_compare(args, case_list, report, get_advance_args=None):
    output_path = os.path.realpath(args.output_path)
    # run operator
    path = os.path.join(output_path,
                        case_list[0]['op'].replace('/', '_'))
    if case_list[0].get('st_mode') == 'ms_python_train':
        op_name_fixed = utils.fix_name_lower_with_under(case_list[0]['op'])
        runner = MsOpRunner(path, op_name_fixed, args.soc_version, report)
        runner.process()
    else:
        runner = AclOpRunner(path, args.soc_version, report, get_advance_args)
        runner.process()

        # compare
        result_comparer.compare(report, path)


def _do_mi_cmd(args, cmd, report):
    try:
        if cmd == "get_shape":
            get_shape(args)
        elif cmd == "change_shape":
            change_shape(args)
        elif cmd == "gen":
            # check device id invaild
            _check_device_id(args.device_id)
            _generate_op_project(args, report, True)
        elif cmd == "compare2":
            result_comparer.compare2(args.result_path, args.expect_path)
        elif cmd == "compare":
            # when the report is input,should avoid update the report
            global abnormal_termination
            abnormal_termination = True
            report_path = os.path.realpath(args.report_path)
            utils.check_path_valid(report_path)
            report.load(report_path)
            utils.print_info_log("Load %s success." % args.report_path)
            run_dir = os.path.dirname(report_path)
            result_comparer.compare(report, run_dir)
            report.save(report_path)
            utils.print_info_log('The st report saved in: %s.' % report_path)
            report.console_print()
        else:
            pass
    except utils.OpTestGenException as ex:
        sys.exit(ex.error_info)


def _do_run_cmd(args, report):
    try:
        if args.soc_version == '':
            utils.print_error_log(
                'The value of "soc_version" is empty. Please modify it.')
            sys.exit(utils.OP_TEST_GEN_INVALID_PARAM_ERROR)
        # check device id invaild
        _check_device_id(args.device_id)
        if args.config_file != "":
            # check config_file invalid
            utils.check_path_valid(args.config_file)
            _gen_build_convert_run(args, report)
        else:
            case_list = _generate_op_project(args, report, False)
            _runner_and_compare(args, case_list, report)

    except utils.OpTestGenException as ex:
        sys.exit(ex.error_info)


def _gen_build_convert_run(args, report):
    output_path = os.path.realpath(args.output_path)
    get_advance_args = AdvanceIniParser(args.config_file)
    get_advance_args.get_advance_args_option()
    acl_mode = get_advance_args.get_mode_flag()
    if acl_mode == utils.BOTH_GEN_AND_RUN_ACL_PROJ or \
            acl_mode == utils.BOTH_GEN_AND_RUN_ACL_PROJ_PERFORMANCE:
        # gen op project and build & convert & execute the project.
        case_list = _generate_op_project(args, report, False)
        _runner_and_compare(args, case_list, report, get_advance_args)
    elif acl_mode == utils.ONLY_GEN_WITHOUT_RUN_ACL_PROJ:
        # only gen op project.
        _generate_op_project(args, report, False)
    elif acl_mode == utils.ONLY_RUN_WITHOUT_GEN_ACL_PROJ or \
            acl_mode == utils.ONLY_RUN_WITHOUT_GEN_ACL_PROJ_PERFORMANCE:
        # only build & convert & execute the project.
        # when the report is input,should avoid update the report
        global abnormal_termination
        abnormal_termination = True
        report_path = os.path.join(output_path, 'st_report.json')
        utils.check_path_valid(report_path)
        report.load(report_path)
        utils.print_info_log("Load %s success." % report_path)
        op_case_list = utils.load_json_file(args.input_file)
        if len(op_case_list) == 0:
            utils.print_error_log("Failed to get %s, please check."
                                  % args.input_file)
            raise utils.OpTestGenException(
                utils.OP_TEST_GEN_INVALID_PATH_ERROR)
        op_name = op_case_list[0].get('op')
        st_mode = op_case_list[0].get('st_mode')
        # run operator
        path = os.path.join(output_path, op_name)
        if st_mode == 'ms_python_train':
            op_name_fixed = utils.fix_name_lower_with_under(op_name)
            runner = MsOpRunner(path, op_name_fixed, args.soc_version, report)
            runner.process()
        else:
            runner = AclOpRunner(path, args.soc_version,
                                 report, get_advance_args)
            runner.process()
            # compare
            result_comparer.compare(report, path)
            report.save(report_path)
            utils.print_info_log('The st report saved in: %s.' % report_path)


def _create_parser(create_parser):
    """
    parse create cmd
    :param create_parser:
    """
    create_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .ini file", required=True)
    create_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)
    create_parser.add_argument(
        "-m", "--model", dest="model_path", default="",
        help="<Optional> the model path", required=False)
    create_parser.add_argument(
        '-q', "--quiet", dest="quiet", action="store_true", default=False,
        help="<Optional> quiet mode, skip human-computer interactions",
        required=False)


def _run_parser(run_parser):
    """
    parse run cmd
    :param run_parser:
    """
    run_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .json file, ", required=True)
    run_parser.add_argument(
        '-soc', "--soc_version", dest="soc_version",
        help="<Required> the soc version to run", required=True)
    run_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)
    run_parser.add_argument(
        '-c', "--case_name", dest="case_name", default='all',
        help="<Optional> the case name to run or gen, splits with ',', "
             "like 'case0,case1'.", required=False)
    run_parser.add_argument(
        '-d', "--device_id", dest="device_id", default="0",
        help="<Optional> input device id, default is 0."
        , required=False)
    run_parser.add_argument(
        '-conf', "--config_file", dest="config_file", default="",
        help="<Optional> config_file, msopst advance config file.",
        required=False)


def _mi_parser(mi_parser):
    """
    parse mi cmd
    :param mi_parser:
    """
    subparsers = mi_parser.add_subparsers(help='commands')
    get_shape_parser = subparsers.add_parser(
        'get_shape', help='Get shape.')
    change_shape_parser = subparsers.add_parser(
        'change_shape', help='Change shape.')
    gen_parser = subparsers.add_parser(
        'gen', help='Generate test case resource.')
    compare_parser = subparsers.add_parser(
        'compare', help='Compare result data with expect output.')
    compare2_parser = subparsers.add_parser(
        'compare2', help='Compare result data with expect output by st '
                         'report.')

    # get shape parser
    get_shape_parser.add_argument(
        "-m", "--model", dest="model_path", default="",
        help="<Required> the model path", required=True)
    get_shape_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)

    # change shape parser
    change_shape_parser.add_argument(
        "-m", "--model", dest="model_path", default="",
        help="<Required> the model path", required=True)
    change_shape_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .json file", required=True)
    change_shape_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)

    # gen parser
    gen_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .json file, ", required=True)
    gen_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)
    gen_parser.add_argument(
        '-c', "--case_name", dest="case_name", default='all',
        help="<Optional> the case name to run or gen, splits with ',', like "
             "'case0,case1'.", required=False)
    gen_parser.add_argument(
        '-d', "--device_id", dest="device_id", default="0",
        help="<Optional> input device id, default is 0."
        , required=False)

    # compare parse
    compare_parser.add_argument(
        "-i", "--report path", dest="report_path", default="",
        help="<Required> the st report file path",
        required=False)
    compare_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)

    # comapre2 parse
    compare2_parser.add_argument(
        "-result", "--result path", dest="result_path", default="",
        help="<Required> the result file path, ", required=True)
    compare2_parser.add_argument(
        "-expect", "--expect path", dest="expect_path", default="",
        help="<Required> the expect result file path",
        required=True)


def save_report(report, output_path):
    if abnormal_termination:
        return
    report_file = os.path.join(os.path.realpath(output_path),
                               'st_report.json')
    report.save(report_file)
    utils.print_info_log('The st report saved in: %s.' % report_file)


def main():
    """
    main function
    :return:
    """
    # parse input argument
    parse = argparse.ArgumentParser()
    subparsers = parse.add_subparsers(help='commands')
    create_parser = subparsers.add_parser(
        'create', help='Create test case json file.', allow_abbrev=False)
    run_parser = subparsers.add_parser(
        'run', help='Run the test case on the aihost.', allow_abbrev=False)
    mi_parser = subparsers.add_parser(
        'mi', help='Interaction with the IDE.', allow_abbrev=False)
    _create_parser(create_parser)
    _run_parser(run_parser)
    _mi_parser(mi_parser)

    if len(sys.argv) <= 1:
        parse.print_usage()
        sys.exit(utils.OP_TEST_GEN_INVALID_PARAM_ERROR)
    args = parse.parse_args(sys.argv[1:])
    # run/mi gen command generator report.
    report = st_report.OpSTReport(" ".join(sys.argv))
    register(save_report, report=report, output_path=args.output_path)
    if sys.argv[1] == 'create':
        # generate test_case.json
        try:
            global abnormal_termination
            abnormal_termination = True
            generator = CaseGenerator(args)
            generator.generate()
        except utils.OpTestGenException as ex:
            sys.exit(ex.error_info)
    elif sys.argv[1] == 'run':
        _do_run_cmd(args, report)
    else:
        _do_mi_cmd(args, sys.argv[2], report)
    utils.print_info_log("Process finished!")
    sys.exit(utils.OP_TEST_GEN_NONE_ERROR)


if __name__ == "__main__":
    main()
