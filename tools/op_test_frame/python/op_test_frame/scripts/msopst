#!/usr/bin/python3
# coding=utf-8
"""
Function:
This file mainly involves class for parsing input arguments.
Copyright Information:
Huawei Technologies Co., Ltd. All Rights Reserved Â© 2020
"""

import os
import sys
import argparse
from op_test_frame.st.interface import utils
from op_test_frame.st.interface.acl_op_runner import AclOpRunner
from op_test_frame.st.interface.ms_op_runner import MsOpRunner
from op_test_frame.st.interface import result_comparer
from op_test_frame.st.interface.acl_op_generator import AclOpGenerator
from op_test_frame.st.interface.ms_op_generator import MsOpGenerator
from op_test_frame.st.interface.case_design import CaseDesign
from op_test_frame.st.interface.case_generator import CaseGenerator
from op_test_frame.st.interface.data_generator import DataGenerator
from op_test_frame.st.interface.model_parser import change_shape
from op_test_frame.st.interface.model_parser import get_shape
from op_test_frame.st.interface import st_report
from atexit import register

abnormal_termination = False


def _check_device_id(device_id):
    if not device_id.isdigit():
        utils.print_error_log(
            'please enter an integer number for device id,'
            'now is %s.' % device_id)
        sys.exit(utils.OP_TEST_GEN_INVALID_DEVICE_ID_ERROR)
    return


def _do_mi_cmd(args, cmd, report):
    try:
        if cmd == "get_shape":
            get_shape(args)
        elif cmd == "change_shape":
            change_shape(args)
        elif cmd == "gen":
            # check device id invaild
            _check_device_id(args.device_id)
            # design test case list from json file
            design = CaseDesign(args.input_file, args.case_name, report)
            case_list = design.design()
            # create acl_op project path and generate op test case code
            output_path = os.path.realpath(args.output_path)
            if case_list[0].get('st_mode') == 'ms_python_train':
                ms_op_generator_instance = MsOpGenerator(
                    case_list, output_path, args.device_id, True, report)
                ms_op_generator_instance.generate()
            else:
                acl_op_generator_instance = AclOpGenerator(
                    case_list, output_path, args.device_id, True, report)
                acl_op_generator_instance.generate()

            # generate data
            data_generator = DataGenerator(case_list, output_path, True,
                                           report)
            data_generator.generate()
        elif cmd == "compare2":
            result_comparer.compare2(args.result_path, args.expect_path)
        elif cmd == "compare":
            # when the report is input,should avoid update the report
            global abnormal_termination
            abnormal_termination = True
            report_path = os.path.realpath(args.report_path)
            utils.check_path_valid(report_path)
            report.load(report_path)
            utils.print_info_log("Load %s success." % args.report_path)
            run_dir = os.path.dirname(report_path)
            result_comparer.compare(report, run_dir)
            report.save(report_path)
            utils.print_info_log('The st report saved in: %s.' % report_path)
            report.console_print()
        else:
            pass
    except utils.OpTestGenException as ex:
        sys.exit(ex.error_info)


def _do_run_cmd(args, report):
    output_path = os.path.realpath(args.output_path)
    try:
        if args.soc_version == '':
            utils.print_error_log(
                'The value of "soc_version" is empty. Please modify it.')
            sys.exit(utils.OP_TEST_GEN_INVALID_PARAM_ERROR)
        # check device id invaild
        _check_device_id(args.device_id)
        # design test case list from json file
        design = CaseDesign(args.input_file, args.case_name, report)
        case_list = design.design()
        # create op project path and generate op test case code
        if case_list[0].get('st_mode') == 'ms_python_train':
            ms_op_generator_instance = MsOpGenerator(
                case_list, output_path, args.device_id, False, report)
            ms_op_generator_instance.generate()
        else:
            output_path = os.path.realpath(args.output_path)
            acl_op_generator_instance = AclOpGenerator(
                case_list, output_path, args.device_id, False, report)
            acl_op_generator_instance.generate()

        # generate data
        data_generator = DataGenerator(case_list, output_path, False, report)
        data_generator.generate()

        # run operator
        path = os.path.join(output_path,
                            case_list[0]['op'].replace('/', '_'))
        if case_list[0].get('st_mode') == 'ms_python_train':
            op_name_fixed = utils.fix_name_lower_with_under(case_list[0]['op'])
            runner = MsOpRunner(path, op_name_fixed, args.soc_version, report)
            runner.process()
        else:
            runner = AclOpRunner(path, args.soc_version, report)
            runner.process()

            # compare
            result_comparer.compare(report, path)

    except utils.OpTestGenException as ex:
        sys.exit(ex.error_info)


def _create_parser(create_parser):
    """
    parse create cmd
    :param create_parser:
    """
    create_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .ini file", required=True)
    create_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)
    create_parser.add_argument(
        "-m", "--model", dest="model_path", default="",
        help="<Optional> the model path", required=False)
    create_parser.add_argument(
        '-q', "--quiet", dest="quiet", action="store_true", default=False,
        help="<Optional> quiet mode, skip human-computer interactions",
        required=False)


def _run_parser(run_parser):
    """
    parse run cmd
    :param run_parser:
    """
    run_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .json file, ", required=True)
    run_parser.add_argument(
        '-soc', "--soc_version", dest="soc_version",
        help="<Required> the soc version to run", required=True)
    run_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)
    run_parser.add_argument(
        '-c', "--case_name", dest="case_name", default='all',
        help="<Optional> the case name to run or gen, splits with ',', "
             "like 'case0,case1'.", required=False)
    run_parser.add_argument(
        '-d', "--device_id", dest="device_id", default="0",
        help="<Optional> input device id, default is 0."
        , required=False)


def _mi_parser(mi_parser):
    """
    parse mi cmd
    :param mi_parser:
    """
    subparsers = mi_parser.add_subparsers(help='commands')
    get_shape_parser = subparsers.add_parser(
        'get_shape', help='Get shape.')
    change_shape_parser = subparsers.add_parser(
        'change_shape', help='Change shape.')
    gen_parser = subparsers.add_parser(
        'gen', help='Generate test case resource.')
    compare_parser = subparsers.add_parser(
        'compare', help='Compare result data with expect output.')
    compare2_parser = subparsers.add_parser(
        'compare2', help='Compare result data with expect output by st '
                         'report.')

    # get shape parser
    get_shape_parser.add_argument(
        "-m", "--model", dest="model_path", default="",
        help="<Required> the model path", required=True)
    get_shape_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)

    # change shape parser
    change_shape_parser.add_argument(
        "-m", "--model", dest="model_path", default="",
        help="<Required> the model path", required=True)
    change_shape_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .json file", required=True)
    change_shape_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)

    # gen parser
    gen_parser.add_argument(
        "-i", "--input", dest="input_file", default="",
        help="<Required> the input file, .json file, ", required=True)
    gen_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)
    gen_parser.add_argument(
        '-c', "--case_name", dest="case_name", default='all',
        help="<Optional> the case name to run or gen, splits with ',', like "
             "'case0,case1'.", required=False)
    gen_parser.add_argument(
        '-d', "--device_id", dest="device_id", default="0",
        help="<Optional> input device id, default is 0."
        , required=False)

    # compare parse
    compare_parser.add_argument(
        "-i", "--report path", dest="report_path", default="",
        help="<Required> the st report file path",
        required=False)
    compare_parser.add_argument(
        "-out", "--output", dest="output_path", default="",
        help="<Optional> the output path", required=False)

    # comapre2 parse
    compare2_parser.add_argument(
        "-result", "--result path", dest="result_path", default="",
        help="<Required> the result file path, ", required=True)
    compare2_parser.add_argument(
        "-expect", "--expect path", dest="expect_path", default="",
        help="<Required> the expect result file path",
        required=True)


def save_report(report, output_path):
    if abnormal_termination:
        return
    report_file = os.path.join(os.path.realpath(output_path),
                               'st_report.json')
    report.save(report_file)
    utils.print_info_log('The st report saved in: %s.' % report_file)


def main():
    """
    main function
    :return:
    """
    # parse input argument
    parse = argparse.ArgumentParser()
    subparsers = parse.add_subparsers(help='commands')
    create_parser = subparsers.add_parser(
        'create', help='Create test case json file.', allow_abbrev=False)
    run_parser = subparsers.add_parser(
        'run', help='Run the test case on the aihost.', allow_abbrev=False)
    mi_parser = subparsers.add_parser(
        'mi', help='Interaction with the IDE.', allow_abbrev=False)
    _create_parser(create_parser)
    _run_parser(run_parser)
    _mi_parser(mi_parser)

    if len(sys.argv) <= 1:
        parse.print_usage()
        sys.exit(utils.OP_TEST_GEN_INVALID_PARAM_ERROR)
    args = parse.parse_args(sys.argv[1:])
    # run/mi gen command generator report.
    report = st_report.OpSTReport(" ".join(sys.argv))
    register(save_report, report=report, output_path=args.output_path)
    if sys.argv[1] == 'create':
        # generate test_case.json
        try:
            global abnormal_termination
            abnormal_termination = True
            generator = CaseGenerator(args)
            generator.generate()
        except utils.OpTestGenException as ex:
            sys.exit(ex.error_info)
    elif sys.argv[1] == 'run':
        _do_run_cmd(args, report)
    else:
        _do_mi_cmd(args, sys.argv[2], report)
    utils.print_info_log("Process finished!")
    sys.exit(utils.OP_TEST_GEN_NONE_ERROR)


if __name__ == "__main__":
    main()
