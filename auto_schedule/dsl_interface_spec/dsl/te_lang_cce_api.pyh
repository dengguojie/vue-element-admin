# source file:python/te/lang/cce/api.py

STACKLEVEL_FOR_DSL_AUTOCAST = 4
STACKLEVEL_FOR_DSL_NO_AUTOCAST = 2

def ceil(raw_tensor):

def floor(raw_tensor):

def round(raw_tensor):

def trunc(raw_tensor):

def round_half_up(raw_tensor):

def cast_to(data, dtype, f1628IntegerFlag=True):

def vadd(lhs, rhs):

def vsub(lhs, rhs):

def vmul(lhs, rhs):

def vdiv(lhs, rhs):

def vrec(raw_tensor, priority_flag=1):

def vmod(lhs, rhs):

def vmax(lhs, rhs):

def vmin(lhs, rhs):

def vlog(raw_tensor, priority_flag=0):

def vexp(raw_tensor):

def vabs(raw_tensor):

def vsqrt(raw_tensor, priority_flag=0):

def vrsqrt(raw_tensor, priority_flag=0):

def vnot(raw_tensor):

def vor(lhs, rhs):

def vand(lhs, rhs):

def vlogic(lhs, rhs=None, operation='logic_and'):

def vadds(raw_tensor, scalar):

def vmuls(raw_tensor, scalar):

def vmaxs(raw_tensor, scalar):

def vmins(raw_tensor, scalar):

def vaxpy(lhs, rhs, scalar):

def vmla(tensor_0, tensor_1, tensor_2):

def vmadd(tensor_0, tensor_1, tensor_2):

def vcmp(lhs, rhs, operation='lt', mode='bool'):

def vsel(condition, lhs, rhs):

def vcmpsel(lhs, rhs=None, operation='lt', slhs=None, srhs=None):

def vmaddrelu(tensor_0, tensor_1, tensor_2):

def vaddrelu(lhs, rhs):

def vsubrelu(lhs, rhs):

def vrelu(raw_tensor):

def vlrelu(raw_tensor, alpha=0):

def round_to(data, max_value, min_value):

def broadcast(var, shape, output_dtype=None):

def sum(raw_tensor, axis, keepdims=False):

def reduce_min(raw_tensor, axis, keepdims=False, priority_flag=False):

def reduce_max(raw_tensor, axis, keepdims=False, priority_flag=False):

def reduce_prod(raw_tensor, axis, keepdims=False):

def split(data, split_dim, size_splits):

def split_compute_com(data, split_dim, size_splits):

def split_schedule_com(data, split_dim, shape_list, tensor_list):

def concat(raw_tensors, axis):

def inplace_add(lhs, inplace_ids, rhs):

def inplace_sub(lhs, inplace_ids, rhs):

def inplace_update(lhs, inplace_ids, rhs):

def pooling2d(tensor_in, window, stride, pooling_mode, padding_mode="SAME", pad=(0, 0, 0, 0), dilation=(1, 1), data_mode=1, ceil_mode=0, fusion_params=None, impl_mode="high_performance"):

def pooling3d(tensor_in, window, stride, padding_mode="SAME", pads=(0, 0, 0, 0, 0, 0), pooling_mode="MAX", dilation=(1, 1, 1), ceil_mode=0):

def max_pooling3d_grad_grad(orig_input, orig_output, grad_grad, assist_tensor, ksize, strides, pads=(0, 0, 0, 0, 0, 0), data_format="NDHWC", padding="SAME"):

def pooling3d_max_grad_grad(orig_input, orig_output, grad_grad, assist_tensor, ksize, strides, pads=(0, 0, 0, 0, 0, 0), data_format="NDHWC", padding="SAME"):

def auto_schedule(outs, option=None):

def cce_build_code(sch, config_map=None):

def tuple_sum(input_tensor_list, axis, keepdims=False):

def unsorted_segment_sum(tensor, segment_ids, num_segments, init_value=0):

def unsorted_segment_mean(tensor, segment_ids, num_segments, init_value=0):

def unsorted_segment_prod(tensor, segment_ids, num_segments, init_value=0):

def unsorted_segment_min(tensor, segment_ids, num_segments, init_value=0):

def unsorted_segment_max(tensor, segment_ids, num_segments, init_value=0):
